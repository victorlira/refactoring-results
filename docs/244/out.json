[
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack3,784,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265) => (<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>, l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack3, 784)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack70 = new de.congrace.exp4j.UnparsableExpressionException,129,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack70.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack71), 129)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack3,784,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265) => (<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>, l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack3, 784))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack70 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 129
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 129
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": 784
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": 784
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack3",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
					"line": 784
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(),265,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack70 = new de.congrace.exp4j.UnparsableExpressionException,129,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack70.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack71), 129)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(),265,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack70 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 129
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 129
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 265
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 265
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>()",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
					"line": 265
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,specialinvoke l0.<java.lang.Object: void <init>()>(),264,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Object: void <init>()>(), 264)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack70 = new de.congrace.exp4j.UnparsableExpressionException,129,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack70.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack71), 129)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,specialinvoke l0.<java.lang.Object: void <init>()>(),264,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Object: void <init>()>(), 264))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack70 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 129
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 129
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 264
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 264
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "specialinvoke l0.<java.lang.Object: void <init>()>()",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
					"line": 264
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,specialinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace(int)>(0),783,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265) => (<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>, specialinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace(int)>(0), 783)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack22 = new de.congrace.exp4j.UnparsableExpressionException,109,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,specialinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace(int)>(0),783,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265) => (<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>, specialinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace(int)>(0), 783))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack22 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 109
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 109
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": 783
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": 783
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "specialinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace(int)>(0)",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
					"line": 783
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack2,210,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack2, 210)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack70 = new de.congrace.exp4j.UnparsableExpressionException,129,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack70.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack71), 129)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack2,210,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack2, 210))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack70 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 129
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 129
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 210
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 210
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace> = $stack2",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
					"line": 210
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1),66,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) SINK=>BASE: Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,$stack13 = virtualinvoke $stack12.<java.lang.StringBuilder: java.lang.String toString()>(),36,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>, $stack13 = virtualinvoke $stack12.<java.lang.StringBuilder: java.lang.String toString()>(), 36)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l1 := @parameter0: java.lang.String,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1),66,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack13 = virtualinvoke $stack12.<java.lang.StringBuilder: java.lang.String toString()>()",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.UnparsableExpressionException",
					"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
					"line": 36
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": 36
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": 66
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": 66
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1)",
				"location": {
					"file": "",
					"class": "java.lang.Exception",
					"method": "<java.lang.Exception: void <init>(java.lang.String)>",
					"line": 66
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0.<java.lang.Throwable: java.lang.Throwable cause> = l0,197,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, l0.<java.lang.Throwable: java.lang.Throwable cause> = l0, 197)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack22 = new de.congrace.exp4j.UnparsableExpressionException,109,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0.<java.lang.Throwable: java.lang.Throwable cause> = l0,197,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, l0.<java.lang.Throwable: java.lang.Throwable cause> = l0, 197))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack22 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 109
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 109
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 197
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 197
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "l0.<java.lang.Throwable: java.lang.Throwable cause> = l0",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
					"line": 197
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,$stack4 = l0.<java.lang.Throwable: java.lang.Object backtrace>,786,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265) => (<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>, $stack4 = l0.<java.lang.Throwable: java.lang.Object backtrace>, 786)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack70 = new de.congrace.exp4j.UnparsableExpressionException,129,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack70.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack71), 129)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,$stack4 = l0.<java.lang.Throwable: java.lang.Object backtrace>,786,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265) => (<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>, $stack4 = l0.<java.lang.Throwable: java.lang.Object backtrace>, 786))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack70 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 129
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 129
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": 786
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": 786
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "$stack4 = l0.<java.lang.Throwable: java.lang.Object backtrace>",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
					"line": 786
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0.<java.lang.Throwable: java.util.List suppressedExceptions> = $stack3,227,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, l0.<java.lang.Throwable: java.util.List suppressedExceptions> = $stack3, 227)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack70 = new de.congrace.exp4j.UnparsableExpressionException,129,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack70.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack71), 129)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0.<java.lang.Throwable: java.util.List suppressedExceptions> = $stack3,227,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, l0.<java.lang.Throwable: java.util.List suppressedExceptions> = $stack3, 227))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack70 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 129
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 129
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 227
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 227
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "l0.<java.lang.Throwable: java.util.List suppressedExceptions> = $stack3",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
					"line": 227
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,$stack1 = l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace>,781,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265) => (<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>, $stack1 = l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace>, 781)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack70 = new de.congrace.exp4j.UnparsableExpressionException,129,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack70.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack71), 129)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265)) => Node(<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>,$stack1 = l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace>,781,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, virtualinvoke l0.<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>(), 265) => (<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>, $stack1 = l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace>, 781))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack70 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 129
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 129
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": 781
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
	"line": 781
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "$stack1 = l0.<java.lang.Throwable: java.lang.StackTraceElement[] stackTrace>",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: java.lang.Throwable fillInStackTrace()>",
					"line": 781
				}
			}
		]
	}
},
{
	"type": "CONFLUENCE",
	"label": "CF conflict",
	"body": {
		"description": "SOURCE=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack136 = new de.congrace.exp4j.UnparsableExpressionException,75,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>,this := @this: de.congrace.exp4j.UnparsableExpressionException,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l0 := @this: java.lang.Exception,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0 := @this: java.lang.Throwable,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0.<java.lang.Throwable: java.lang.String detailMessage> = l1,266,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, l0.<java.lang.Throwable: java.lang.String detailMessage> = l1, 266)) SINK=>BASE: Node(<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>,$stack71 = i + 1,129,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, $stack71 = i + 1, 129)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,pos := @parameter2: int,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,$stack9 = virtualinvoke $stack8.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(pos),36,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>, $stack9 = virtualinvoke $stack8.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(pos), 36)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,$stack10 = virtualinvoke $stack9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" in expression \'"),36,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>, $stack10 = virtualinvoke $stack9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(' in expression \''), 36)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,$stack11 = virtualinvoke $stack10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(expression),36,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>, $stack11 = virtualinvoke $stack10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(expression), 36)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,$stack12 = virtualinvoke $stack11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\'"),36,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>, $stack12 = virtualinvoke $stack11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>('\''), 36)) => Node(<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>,$stack13 = virtualinvoke $stack12.<java.lang.StringBuilder: java.lang.String toString()>(),36,SourceNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack22.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>(expression, c, $stack23), 109) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>, $stack13 = virtualinvoke $stack12.<java.lang.StringBuilder: java.lang.String toString()>(), 36)) => Node(<java.lang.Exception: void <init>(java.lang.String)>,l1 := @parameter0: java.lang.String,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l1 := @parameter0: java.lang.String,-1,SimpleNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66)) => Node(<java.lang.Throwable: void <init>(java.lang.String)>,l0.<java.lang.Throwable: java.lang.String detailMessage> = l1,266,SinkNode, path: (<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>, specialinvoke $stack136.<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>('Expression can have only one notation separator'), 75) => (<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>, specialinvoke this.<java.lang.Exception: void <init>(java.lang.String)>(msg), 46) => (<java.lang.Exception: void <init>(java.lang.String)>, specialinvoke l0.<java.lang.Throwable: void <init>(java.lang.String)>(l1), 66) => (<java.lang.Throwable: void <init>(java.lang.String)>, l0.<java.lang.Throwable: java.lang.String detailMessage> = l1, 266))",
		"interference": [
			{
				"type": "source1",
				"branch": "L",
				"text": "$stack71 = i + 1",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 129
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 129
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": -1
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": 36
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": 36
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": 36
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": 36
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String,char,int)>",
	"line": 36
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 266
}]
			},
			{
				"type": "source2",
				"branch": "R",
				"text": "$stack136 = new de.congrace.exp4j.UnparsableExpressionException",
				"location": {
					"file": "",
					"class": "de.congrace.exp4j.Tokenizer",
					"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
					"line": 75
				},
				"stackTrace": [{
	"class": "de.congrace.exp4j.Tokenizer",
	"method": "<de.congrace.exp4j.Tokenizer: java.util.List getTokens(java.lang.String)>",
	"line": 75
},{
	"class": "de.congrace.exp4j.UnparsableExpressionException",
	"method": "<de.congrace.exp4j.UnparsableExpressionException: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Exception",
	"method": "<java.lang.Exception: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": -1
},{
	"class": "java.lang.Throwable",
	"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
	"line": 266
}]
			},
			{
				"type": "confluence",
				"branch": "B",
				"text": "l0.<java.lang.Throwable: java.lang.String detailMessage> = l1",
				"location": {
					"file": "",
					"class": "java.lang.Throwable",
					"method": "<java.lang.Throwable: void <init>(java.lang.String)>",
					"line": 266
				}
			}
		]
	}
}

]
